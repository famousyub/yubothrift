/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef calculator_TYPES_H
#define calculator_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace calculator {

struct BinaryOperation {
  enum type {
    ADDITION = 1,
    SUBTRACTION = 2,
    MULTIPLICATION = 3,
    DIVISION = 4,
    MODULUS = 5
  };
};

extern const std::map<int, const char*> _BinaryOperation_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const BinaryOperation::type& val);

std::string to_string(const BinaryOperation::type& val);

typedef std::vector<double>  Vector;

class ArithmeticOperation;

class ArithmeticException;

class Matrix;

class MatrixException;

typedef struct _ArithmeticOperation__isset {
  _ArithmeticOperation__isset() : op(false), lh_term(false), rh_term(false) {}
  bool op :1;
  bool lh_term :1;
  bool rh_term :1;
} _ArithmeticOperation__isset;

class ArithmeticOperation : public virtual ::apache::thrift::TBase {
 public:

  ArithmeticOperation(const ArithmeticOperation&) noexcept;
  ArithmeticOperation& operator=(const ArithmeticOperation&) noexcept;
  ArithmeticOperation() noexcept
                      : op(static_cast<BinaryOperation::type>(0)),
                        lh_term(0),
                        rh_term(0) {
  }

  virtual ~ArithmeticOperation() noexcept;
  /**
   * 
   * @see BinaryOperation
   */
  BinaryOperation::type op;
  double lh_term;
  double rh_term;

  _ArithmeticOperation__isset __isset;

  void __set_op(const BinaryOperation::type val);

  void __set_lh_term(const double val);

  void __set_rh_term(const double val);

  bool operator == (const ArithmeticOperation & rhs) const
  {
    if (!(op == rhs.op))
      return false;
    if (!(lh_term == rhs.lh_term))
      return false;
    if (!(rh_term == rhs.rh_term))
      return false;
    return true;
  }
  bool operator != (const ArithmeticOperation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ArithmeticOperation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ArithmeticOperation &a, ArithmeticOperation &b);

std::ostream& operator<<(std::ostream& out, const ArithmeticOperation& obj);

typedef struct _ArithmeticException__isset {
  _ArithmeticException__isset() : msg(false), x(false) {}
  bool msg :1;
  bool x :1;
} _ArithmeticException__isset;

class ArithmeticException : public ::apache::thrift::TException {
 public:

  ArithmeticException(const ArithmeticException&);
  ArithmeticException& operator=(const ArithmeticException&);
  ArithmeticException() noexcept
                      : msg(),
                        x(0) {
  }

  virtual ~ArithmeticException() noexcept;
  std::string msg;
  double x;

  _ArithmeticException__isset __isset;

  void __set_msg(const std::string& val);

  void __set_x(const double val);

  bool operator == (const ArithmeticException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    if (__isset.x != rhs.__isset.x)
      return false;
    else if (__isset.x && !(x == rhs.x))
      return false;
    return true;
  }
  bool operator != (const ArithmeticException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ArithmeticException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(ArithmeticException &a, ArithmeticException &b);

std::ostream& operator<<(std::ostream& out, const ArithmeticException& obj);

typedef struct _Matrix__isset {
  _Matrix__isset() : rows(false), cols(false), data(false) {}
  bool rows :1;
  bool cols :1;
  bool data :1;
} _Matrix__isset;

class Matrix : public virtual ::apache::thrift::TBase {
 public:

  Matrix(const Matrix&);
  Matrix& operator=(const Matrix&);
  Matrix() noexcept
         : rows(0),
           cols(0) {
  }

  virtual ~Matrix() noexcept;
  int64_t rows;
  int64_t cols;
  std::vector<Vector>  data;

  _Matrix__isset __isset;

  void __set_rows(const int64_t val);

  void __set_cols(const int64_t val);

  void __set_data(const std::vector<Vector> & val);

  bool operator == (const Matrix & rhs) const
  {
    if (!(rows == rhs.rows))
      return false;
    if (!(cols == rhs.cols))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Matrix &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Matrix & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Matrix &a, Matrix &b);

std::ostream& operator<<(std::ostream& out, const Matrix& obj);

typedef struct _MatrixException__isset {
  _MatrixException__isset() : msg(false) {}
  bool msg :1;
} _MatrixException__isset;

class MatrixException : public ::apache::thrift::TException {
 public:

  MatrixException(const MatrixException&);
  MatrixException& operator=(const MatrixException&);
  MatrixException() noexcept
                  : msg() {
  }

  virtual ~MatrixException() noexcept;
  std::string msg;

  _MatrixException__isset __isset;

  void __set_msg(const std::string& val);

  bool operator == (const MatrixException & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const MatrixException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatrixException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(MatrixException &a, MatrixException &b);

std::ostream& operator<<(std::ostream& out, const MatrixException& obj);

} // namespace

#endif
